import 'dart:io';
import 'package:pdf/pdf.dart';
import 'package:pdf/widgets.dart' as pw;
import 'package:path_provider/path_provider.dart';
import 'package:file_picker/file_picker.dart';
import '../services/local_storage_service.dart';
import 'dart:typed_data';
import 'file_writer.dart';
import 'package:flutter/foundation.dart';

class PDFService {
  /// Generate and save PDF with user file picker
  static Future<String?> generateAndSavePDFWithPicker({
    required String imagePath,
    required Map<String, dynamic> apiResponse,
    String? suggestedFileName,
  }) async {
    try {
      // Generate the PDF first
      final pdf = await _generateSinglePDF(imagePath, apiResponse);
      if (pdf == null) return null;

      // Let user pick where to save
      return await _savePDFWithPicker(
        pdf,
        suggestedFileName ??
            'damage_assessment_${DateTime.now().toString().split(' ')[0]}.pdf',
      );
    } catch (e) {
      print('Error generating PDF with picker: $e');
      return null;
    }
  }

  /// Generate and save multiple results PDF with user file picker
  static Future<String?> generateAndSaveMultiplePDFWithPicker({
    required List<String> imagePaths,
    required Map<String, Map<String, dynamic>> apiResponses,
    String? suggestedFileName,
  }) async {
    try {
      // Generate the PDF first
      final pdf = await _generateMultiplePDF(imagePaths, apiResponses);
      if (pdf == null) return null;

      // Let user pick where to save
      return await _savePDFWithPicker(
        pdf,
        suggestedFileName ??
            'multi_damage_assessment_${DateTime.now().toString().split(' ')[0]}.pdf',
      );
    } catch (e) {
      print('Error generating multiple PDF with picker: $e');
      return null;
    }
  }

  /// Generate PDF document for single result
  static Future<pw.Document?> _generateSinglePDF(
    String imagePath,
    Map<String, dynamic> apiResponse,
  ) async {
    try {
      final pdf = pw.Document();

      // Load image for PDF with better error handling
      pw.ImageProvider? image;
      try {
        final imageFile = File(imagePath);
        if (await imageFile.exists()) {
          final imageBytes = await imageFile.readAsBytes();
          image = pw.MemoryImage(imageBytes);
        } else {
          print('Warning: Image file does not exist at path: $imagePath');
          // Continue without image - PDF will still be generated
        }
      } catch (e) {
        print('Warning: Failed to load image for PDF: $e');
        // Continue without image - PDF will still be generated
      }

      // Extract data from API response
      final overallSeverity =
          apiResponse['overall_severity']?.toString() ?? 'Unknown';
      final isSevere = overallSeverity.toLowerCase() == 'severe';
      final totalCost =
          apiResponse['total_cost']?.toString() ?? 'Not available';
      final damages = apiResponse['damages'] ?? apiResponse['prediction'] ?? [];

      // Format cost
      String formattedCost;
      if (isSevere) {
        formattedCost = 'Not available';
      } else {
        formattedCost = 'Not available';
        if (totalCost != 'Not available') {
          try {
            final cost = double.parse(totalCost);
            formattedCost =
                'PHP ${cost.toStringAsFixed(2)}'; // Use PHP instead of ₱ symbol
          } catch (e) {
            formattedCost = 'PHP $totalCost';
          }
        }
      }

      pdf.addPage(
        pw.MultiPage(
          pageFormat: PdfPageFormat.a4,
          margin: const pw.EdgeInsets.all(32),
          build: (pw.Context context) {
            return [
              // Header
              pw.Header(
                level: 0,
                child: pw.Text(
                  'Vehicle Damage Assessment Report',
                  style: pw.TextStyle(
                    fontSize: 24,
                    fontWeight: pw.FontWeight.bold,
                  ),
                ),
              ),

              pw.SizedBox(height: 20),

              // Report details
              pw.Row(
                mainAxisAlignment: pw.MainAxisAlignment.spaceBetween,
                children: [
                  pw.Text(
                    'Report Date: ${DateTime.now().toString().split(' ')[0]}',
                    style: const pw.TextStyle(fontSize: 12),
                  ),
                  pw.Text(
                    'Generated by InsureVis',
                    style: const pw.TextStyle(fontSize: 12),
                  ),
                ],
              ),

              pw.SizedBox(height: 30),

              // Image section
              if (image != null) ...[
                pw.Container(
                  alignment: pw.Alignment.center,
                  child: pw.Column(
                    children: [
                      pw.Text(
                        'Analyzed Image',
                        style: pw.TextStyle(
                          fontSize: 16,
                          fontWeight: pw.FontWeight.bold,
                        ),
                      ),
                      pw.SizedBox(height: 10),
                      pw.Container(
                        height: 300,
                        child: pw.Image(image, fit: pw.BoxFit.contain),
                      ),
                    ],
                  ),
                ),
                pw.SizedBox(height: 30),
              ] else ...[
                pw.Container(
                  alignment: pw.Alignment.center,
                  padding: const pw.EdgeInsets.all(20),
                  decoration: pw.BoxDecoration(
                    border: pw.Border.all(color: PdfColors.grey400),
                    borderRadius: pw.BorderRadius.circular(8),
                  ),
                  child: pw.Column(
                    children: [
                      pw.Text(
                        '[Camera Icon]', // Use text instead of icon
                        style: pw.TextStyle(
                          fontSize: 14,
                          color: PdfColors.grey600,
                        ),
                      ),
                      pw.SizedBox(height: 10),
                      pw.Text(
                        'Image not available for display',
                        style: pw.TextStyle(
                          fontSize: 14,
                          color: PdfColors.grey600,
                        ),
                      ),
                    ],
                  ),
                ),
                pw.SizedBox(height: 30),
              ],

              // Assessment summary
              pw.Container(
                padding: const pw.EdgeInsets.all(16),
                decoration: pw.BoxDecoration(
                  border: pw.Border.all(color: PdfColors.grey300),
                  borderRadius: const pw.BorderRadius.all(
                    pw.Radius.circular(8),
                  ),
                ),
                child: pw.Column(
                  crossAxisAlignment: pw.CrossAxisAlignment.start,
                  children: [
                    pw.Text(
                      'Assessment Summary',
                      style: pw.TextStyle(
                        fontSize: 18,
                        fontWeight: pw.FontWeight.bold,
                      ),
                    ),
                    pw.SizedBox(height: 15),

                    pw.Row(
                      children: [
                        pw.Expanded(
                          child: pw.Column(
                            crossAxisAlignment: pw.CrossAxisAlignment.start,
                            children: [
                              pw.Text(
                                'Overall Severity',
                                style: pw.TextStyle(
                                  fontWeight: pw.FontWeight.bold,
                                  fontSize: 14,
                                ),
                              ),
                              pw.SizedBox(height: 5),
                              pw.Text(
                                _capitalizeFirst(overallSeverity),
                                style: const pw.TextStyle(fontSize: 12),
                              ),
                            ],
                          ),
                        ),
                        pw.Expanded(
                          child: pw.Column(
                            crossAxisAlignment: pw.CrossAxisAlignment.start,
                            children: [
                              pw.Text(
                                'Estimated Cost',
                                style: pw.TextStyle(
                                  fontWeight: pw.FontWeight.bold,
                                  fontSize: 14,
                                ),
                              ),
                              pw.SizedBox(height: 5),
                              pw.Text(
                                formattedCost,
                                style: const pw.TextStyle(fontSize: 12),
                              ),
                            ],
                          ),
                        ),
                      ],
                    ),
                  ],
                ),
              ),

              pw.SizedBox(height: 20),

              // Damages section
              if (damages.isNotEmpty && !isSevere) ...[
                pw.Text(
                  'Detected Damages',
                  style: pw.TextStyle(
                    fontSize: 18,
                    fontWeight: pw.FontWeight.bold,
                  ),
                ),
                pw.SizedBox(height: 10),

                ...damages.map((damage) {
                  String damageType = 'Unknown';
                  String severity = '';

                  if (damage is Map<String, dynamic>) {
                    damageType =
                        damage['type']?.toString() ??
                        damage['damage_type']?.toString() ??
                        'Unknown';
                    severity = damage['severity']?.toString() ?? '';
                  } else if (damage is String) {
                    damageType = damage;
                  }

                  return pw.Container(
                    margin: const pw.EdgeInsets.only(bottom: 8),
                    padding: const pw.EdgeInsets.all(12),
                    decoration: pw.BoxDecoration(
                      color: PdfColors.grey100,
                      borderRadius: const pw.BorderRadius.all(
                        pw.Radius.circular(6),
                      ),
                    ),
                    child: pw.Row(
                      children: [
                        pw.Text(
                          '* ',
                          style: const pw.TextStyle(fontSize: 16),
                        ), // Use asterisk instead of bullet
                        pw.Expanded(
                          child: pw.Text(
                            _capitalizeFirst(damageType),
                            style: const pw.TextStyle(fontSize: 12),
                          ),
                        ),
                        if (severity.isNotEmpty)
                          pw.Container(
                            padding: const pw.EdgeInsets.symmetric(
                              horizontal: 8,
                              vertical: 2,
                            ),
                            decoration: pw.BoxDecoration(
                              color: PdfColors.grey300,
                              borderRadius: const pw.BorderRadius.all(
                                pw.Radius.circular(4),
                              ),
                            ),
                            child: pw.Text(
                              _capitalizeFirst(severity),
                              style: const pw.TextStyle(fontSize: 10),
                            ),
                          ),
                      ],
                    ),
                  );
                }).toList(),
              ],

              pw.SizedBox(height: 30),

              // Footer
              pw.Container(
                alignment: pw.Alignment.center,
                child: pw.Text(
                  'This report was generated automatically by InsureVis AI system.',
                  style: const pw.TextStyle(
                    fontSize: 10,
                    color: PdfColors.grey600,
                  ),
                ),
              ),
            ];
          },
        ),
      );

      return pdf;
    } catch (e) {
      print('Error generating single PDF: $e');
      return null;
    }
  }

  /// Generate PDF document for multiple results
  static Future<pw.Document?> _generateMultiplePDF(
    List<String> imagePaths,
    Map<String, Map<String, dynamic>> apiResponses,
  ) async {
    try {
      final pdf = pw.Document();

      for (var i = 0; i < imagePaths.length; i++) {
        final imagePath = imagePaths[i];

        // Try to pick matching API response by imagePath key; otherwise
        // fall back to a best-effort element by index or empty map.
        Map<String, dynamic> apiResponse = {};
        if (apiResponses.isNotEmpty) {
          if (apiResponses.containsKey(imagePath)) {
            apiResponse = apiResponses[imagePath] ?? {};
          } else if (apiResponses.length > i) {
            apiResponse = apiResponses.values.elementAt(i);
          } else {
            apiResponse = apiResponses.values.first;
          }
        }

        pdf.addPage(
          pw.MultiPage(
            pageFormat: PdfPageFormat.a4,
            margin: const pw.EdgeInsets.all(32),
            build:
                (pw.Context context) => [
                  _buildIndividualResult(i + 1, imagePath, apiResponse),
                ],
          ),
        );
      }

      return pdf;
    } catch (e) {
      print('Error generating multiple PDF: $e');
      return null;
    }
  }

  static Future<String?> generateMultipleResultsPDF({
    required List<String> imagePaths,
    required Map<String, Map<String, dynamic>> apiResponses,
  }) async {
    try {
      final pdf = await _generateMultiplePDF(imagePaths, apiResponses);
      if (pdf == null) return null;

      return await _savePDF(
        pdf,
        'multi_damage_assessment_${DateTime.now().toString().split(' ')[0]}.pdf',
      );
    } catch (e) {
      print('Error generating multi-results PDF: $e');
      print('Stack trace: ${StackTrace.current}');
      return null;
    }
  }

  /// Generate PDF bytes for multiple results and return as Uint8List
  static Future<Uint8List?> generateMultipleResultsPDFBytes({
    required List<String> imagePaths,
    required Map<String, Map<String, dynamic>> apiResponses,
  }) async {
    try {
      final pdf = await _generateMultiplePDF(imagePaths, apiResponses);
      if (pdf == null) return null;
      final bytes = await pdf.save();
      return Uint8List.fromList(bytes);
    } catch (e) {
      print('Error generating PDF bytes: $e');
      return null;
    }
  }

  /// Save given pdf bytes into the specified directory path (filesystem).
  /// Returns the saved filepath on success or null on failure.
  static Future<String?> savePdfBytesToDirectory(
    Uint8List pdfBytes,
    String fileName,
    String directoryPath,
  ) async {
    try {
      final directory = Directory(directoryPath);
      if (!await directory.exists()) {
        await directory.create(recursive: true);
      }

      // Ensure unique filename
      String finalFileName = fileName;
      int counter = 1;
      while (await File('${directory.path}/$finalFileName').exists()) {
        final nameWithoutExtension = fileName.replaceAll('.pdf', '');
        finalFileName = '${nameWithoutExtension}_$counter.pdf';
        counter++;
      }

      final file = File('${directory.path}/$finalFileName');
      await file.writeAsBytes(pdfBytes);

      if (await file.exists() && await file.length() > 0) {
        return file.path;
      }
      return null;
    } catch (e) {
      print('Error saving PDF to directory: $e');
      return null;
    }
  }

  /// Return true when a filesystem path is under one of the app-allowed
  /// directories (app documents, app external or known external documents).
  /// This prevents attempts to write to odd absolute paths returned by some
  /// pickers (for example '/document') which are not writable by dart:io.
  static Future<bool> _isPathUnderAllowedDirs(String path) async {
    try {
      if (path.isEmpty) return false;

      // Accept content URIs separately
      if (path.startsWith('content://')) return false;

      // Normalize to simple form for startsWith checks
      final normalized = path.replaceAll('\\', '/');

      // App documents dir
      final appDoc = await getApplicationDocumentsDirectory();
      if (normalized.startsWith(appDoc.path)) return true;

      // App external dir
      try {
        final ext = await getExternalStorageDirectory();
        if (ext != null && normalized.startsWith(ext.path)) return true;
      } catch (_) {}

      // Public external documents directories
      try {
        final externalDocs = await getExternalStorageDirectories(
          type: StorageDirectory.documents,
        );
        if (externalDocs != null) {
          for (final d in externalDocs) {
            if (normalized.startsWith(d.path)) return true;
          }
        }
      } catch (_) {}

      return false;
    } catch (e) {
      print('Error validating path allowed dirs: $e');
      return false;
    }
  }

  /// Present a FilePicker save dialog and write bytes to the returned path.
  /// Handles content:// URIs via the platform writer.
  static Future<String?> savePdfBytesWithPicker(
    Uint8List pdfBytes,
    String suggestedFileName,
  ) async {
    try {
      String? outputFile = await FilePicker.platform.saveFile(
        dialogTitle: 'Save PDF Report',
        fileName: suggestedFileName,
        type: FileType.custom,
        allowedExtensions: ['pdf'],
        bytes: pdfBytes,
      );

      if (outputFile == null) return null;

      if (!outputFile.toLowerCase().endsWith('.pdf')) {
        outputFile = '$outputFile.pdf';
      }

      // If the picker returned a content URI, use the platform writer.
      if (outputFile.startsWith('content://')) {
        await FileWriter.writeBytesToUri(outputFile, pdfBytes);
        return outputFile;
      }

      // If the picker returned an absolute path that is NOT under one of the
      // app-allowed directories, avoid trying a dart:io write which will
      // frequently fail on Android with odd paths like '/document'. Instead
      // fall back to saving into the app-controlled documents folder.
      if (outputFile.startsWith('/')) {
        final allowed = await _isPathUnderAllowedDirs(outputFile);
        if (!allowed) {
          print(
            'Picker returned unsafe absolute path ($outputFile). Falling back to app documents save.',
          );
          final fallback = await LocalStorageService.saveFileToDocuments(
            pdfBytes,
            suggestedFileName,
            allowPicker: false,
          );
          return fallback;
        }
      }

      // Regular filesystem path under allowed directory - write with dart:io
      final file = File(outputFile);
      final directory = file.parent;
      if (!await directory.exists()) await directory.create(recursive: true);
      await file.writeAsBytes(pdfBytes);
      if (await file.exists() && await file.length() > 0) return file.path;
      return null;
    } catch (e) {
      print('Error saving PDF with picker: $e');
      return null;
    }
  }

  static pw.Widget _buildIndividualResult(
    int imageNumber,
    String imagePath,
    Map<String, dynamic> apiResponse,
  ) {
    final overallSeverity =
        apiResponse['overall_severity']?.toString() ?? 'Unknown';
    final isSevere = overallSeverity.toLowerCase() == 'severe';
    final totalCost = apiResponse['total_cost']?.toString() ?? 'Not available';
    final damages = apiResponse['damages'] ?? apiResponse['prediction'] ?? [];

    String formattedCost;
    if (isSevere) {
      formattedCost = 'Not available';
    } else {
      formattedCost = 'Not available';
      if (totalCost != 'Not available') {
        try {
          final cost = double.parse(totalCost);
          formattedCost = '₱${cost.toStringAsFixed(2)}';
        } catch (e) {
          // This will catch cases where the cost is already a string like "To be given..."
          formattedCost = totalCost;
        }
      }
    }

    return pw.Container(
      margin: const pw.EdgeInsets.only(bottom: 30),
      padding: const pw.EdgeInsets.all(16),
      decoration: pw.BoxDecoration(
        border: pw.Border.all(color: PdfColors.grey300),
        borderRadius: const pw.BorderRadius.all(pw.Radius.circular(8)),
      ),
      child: pw.Column(
        crossAxisAlignment: pw.CrossAxisAlignment.start,
        children: [
          pw.Text(
            'Image $imageNumber Analysis',
            style: pw.TextStyle(fontSize: 16, fontWeight: pw.FontWeight.bold),
          ),

          pw.SizedBox(height: 15),

          // Summary row
          pw.Row(
            children: [
              pw.Expanded(
                child: pw.Column(
                  crossAxisAlignment: pw.CrossAxisAlignment.start,
                  children: [
                    pw.Text(
                      'Severity: ${_capitalizeFirst(overallSeverity)}',
                      style: const pw.TextStyle(fontSize: 12),
                    ),
                    pw.SizedBox(height: 5),
                    pw.Text(
                      'Cost: $formattedCost',
                      style: const pw.TextStyle(fontSize: 12),
                    ),
                  ],
                ),
              ),
              pw.Text(
                'Damages: ${damages.length}',
                style: const pw.TextStyle(fontSize: 12),
              ),
            ],
          ),

          if (damages.isNotEmpty && !isSevere) ...[
            pw.SizedBox(height: 10),
            pw.Text(
              'Detected Damages:',
              style: pw.TextStyle(fontSize: 12, fontWeight: pw.FontWeight.bold),
            ),
            pw.SizedBox(height: 5),
            ...damages.take(3).map((damage) {
              String damageType = 'Unknown';
              if (damage is Map<String, dynamic>) {
                damageType =
                    damage['type']?.toString() ??
                    damage['damage_type']?.toString() ??
                    'Unknown';
              } else if (damage is String) {
                damageType = damage;
              }

              return pw.Text(
                '* ${_capitalizeFirst(damageType)}', // Use asterisk instead of bullet
                style: const pw.TextStyle(fontSize: 10),
              );
            }).toList(),
            if (damages.length > 3)
              pw.Text(
                '* + ${damages.length - 3} more damages', // Use asterisk instead of bullet
                style: pw.TextStyle(
                  fontSize: 10,
                  fontStyle: pw.FontStyle.italic,
                ),
              ),
          ],
        ],
      ),
    );
  }

  static Future<String?> _savePDF(pw.Document pdf, String fileName) async {
    try {
      // Generate PDF bytes once
      final bytesList = await pdf.save();
      final pdfBytes = Uint8List.fromList(bytesList);

      // First, try the file picker flow (desktop or SAF on supported platforms)
      try {
        final pickedPath = await savePdfBytesWithPicker(pdfBytes, fileName);
        if (pickedPath != null) return pickedPath;
      } catch (e) {
        print('Picker save attempt failed: $e');
      }

      // Next, try the LocalStorageService which itself prefers a picker and
      // will fall back to the app documents directory (no creating top-level
      // InsureVis folders).
      try {
        final saved = await LocalStorageService.saveFileToDocuments(
          pdfBytes,
          fileName,
          allowPicker: false,
        );
        if (saved != null) return saved;
      } catch (e) {
        print('LocalStorageService save failed: $e');
      }

      // Last resort: write to a system temp directory
      try {
        final tempDir = Directory.systemTemp.createTempSync('pdf_fallback_');
        final fallbackFile = File('${tempDir.path}/$fileName');
        await fallbackFile.writeAsBytes(pdfBytes);
        if (await fallbackFile.exists() && await fallbackFile.length() > 0) {
          print('Fallback save successful: ${fallbackFile.path}');
          return fallbackFile.path;
        }
      } catch (e) {
        print('Fallback temp save failed: $e');
      }

      return null;
    } catch (e) {
      print('Error saving PDF: $e');
      return null;
    }
  }

  /// Save PDF using file picker - let user choose location
  static Future<String?> _savePDFWithPicker(
    pw.Document pdf,
    String suggestedFileName,
  ) async {
    try {
      // On mobile platforms FilePicker.platform.saveFile is not reliable
      // (often unsupported or returns content URIs that can't be written
      // with dart:io File). In that case, don't generate PDF bytes here;
      // delegate to the normal _savePDF path which will generate bytes
      // once and perform the picker-first/fallback logic there. This
      // avoids generating the PDF twice on mobile.
      if (Platform.isAndroid || Platform.isIOS) {
        print(
          'FilePicker.saveFile not supported on mobile; falling back to default save',
        );
        return await _savePDF(pdf, suggestedFileName);
      }

      // Desktop/non-mobile: generate PDF bytes for direct picker write
      final pdfBytes = await pdf.save();

      // Use FilePicker to let user choose save location (desktop)
      String? outputFile = await FilePicker.platform.saveFile(
        dialogTitle: 'Save PDF Report',
        fileName: suggestedFileName,
        type: FileType.custom,
        allowedExtensions: ['pdf'],
        bytes: pdfBytes,
      );

      if (outputFile == null) {
        print('User cancelled file picker');
        return null;
      }

      // Ensure the file has .pdf extension
      if (!outputFile.toLowerCase().endsWith('.pdf')) {
        outputFile = '$outputFile.pdf';
      }

      // If the picker returned a content:// URI (Android SAF), use the
      // platform channel writer to write bytes. On desktop we can write
      // directly with dart:io File. If the picker returned an absolute path
      // that looks unsafe on Android, avoid dart:io writes and fallback.
      if (outputFile.startsWith('content://')) {
        try {
          // Use platform-specific code to write to content URI
          await FileWriter.writeBytesToUri(
            outputFile,
            Uint8List.fromList(pdfBytes),
          );
        } catch (e) {
          throw Exception('Failed to write to content URI: $e');
        }
      } else if (outputFile.startsWith('/')) {
        final allowed = await _isPathUnderAllowedDirs(outputFile);
        if (!allowed) {
          print(
            'User picked an absolute path that is not under allowed directories: $outputFile',
          );
          print('Falling back to default save location...');
          return await _savePDF(pdf, suggestedFileName);
        }

        // Allowed path - write with dart:io
        final file = File(outputFile);
        final directory = file.parent;
        if (!await directory.exists()) await directory.create(recursive: true);
        await file.writeAsBytes(pdfBytes);
      } else {
        // Create and write the file (regular filesystem path)
        final file = File(outputFile);

        // Create parent directories if they don't exist
        final directory = file.parent;
        if (!await directory.exists()) {
          await directory.create(recursive: true);
        }

        // Write the PDF bytes
        await file.writeAsBytes(pdfBytes);
      }

      // Verify file was written successfully
      if (outputFile.startsWith('content://')) {
        // On content URIs we rely on the platform writer to signal success.
        print('PDF written to content URI: $outputFile');
        print('PDF size: ${pdfBytes.length} bytes');
        return outputFile;
      } else {
        final writtenFile = File(outputFile);
        if (await writtenFile.exists() && await writtenFile.length() > 0) {
          print(
            'PDF saved successfully to user-chosen location: ${writtenFile.path}',
          );
          print('PDF size: ${pdfBytes.length} bytes');
          return writtenFile.path;
        } else {
          throw Exception(
            'File was not written successfully to chosen location',
          );
        }
      }
    } catch (e) {
      print('Error saving PDF with file picker: $e');

      // Fallback to default save method
      print('Falling back to default save location...');
      return await _savePDF(pdf, suggestedFileName);
    }
  }

  static String _capitalizeFirst(String text) {
    if (text.isEmpty) return text;
    return text[0].toUpperCase() + text.substring(1).toLowerCase();
  }
}
